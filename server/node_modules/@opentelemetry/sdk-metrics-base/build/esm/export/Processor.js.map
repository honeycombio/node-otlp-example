{"version":3,"file":"Processor.js","sourceRoot":"","sources":["../../../src/export/Processor.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;GAcG;;;;;;;;;;;;;;;;AAEH,OAAO,KAAK,WAAW,MAAM,eAAe,CAAC;AAC7C,OAAO,EAEL,UAAU,GAGX,MAAM,SAAS,CAAC;AAEjB;;;;;;GAMG;AACH;IAAA;QACqB,cAAS,GAAG,IAAI,GAAG,EAAwB,CAAC;IAWjE,CAAC;IAHC,iCAAa,GAAb;QACE,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,CAAC,CAAC;IAC7C,CAAC;IACH,gBAAC;AAAD,CAAC,AAZD,IAYC;;AAED;;;GAGG;AACH;IAAwC,sCAAS;IAAjD;;IA4BA,CAAC;IA3BC,0CAAa,GAAb,UAAc,gBAAkC;QAC9C,QAAQ,gBAAgB,CAAC,UAAU,EAAE;YACnC,KAAK,UAAU,CAAC,OAAO,CAAC;YACxB,KAAK,UAAU,CAAC,eAAe;gBAC7B,OAAO,IAAI,WAAW,CAAC,aAAa,EAAE,CAAC;YAEzC,KAAK,UAAU,CAAC,kBAAkB,CAAC;YACnC,KAAK,UAAU,CAAC,0BAA0B,CAAC;YAC3C,KAAK,UAAU,CAAC,gBAAgB;gBAC9B,OAAO,IAAI,WAAW,CAAC,mBAAmB,EAAE,CAAC;YAE/C,KAAK,UAAU,CAAC,SAAS;gBACvB,OAAO,IAAI,WAAW,CAAC,mBAAmB,CACxC,gBAAgB,CAAC,UAAU,IAAI,CAAC,QAAQ,CAAC,CAC1C,CAAC;YAEJ;gBACE,OAAO,IAAI,WAAW,CAAC,mBAAmB,EAAE,CAAC;SAChD;IACH,CAAC;IAED,oCAAO,GAAP,UAAQ,MAAoB;QAC1B,IAAM,UAAU,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC;aAC9C,GAAG,CAAC,UAAA,CAAC,IAAI,OAAG,CAAC,SAAI,MAAM,CAAC,UAAU,CAAC,CAAC,CAAG,EAA9B,CAA8B,CAAC;aACxC,IAAI,CAAC,GAAG,CAAC,CAAC;QACb,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,GAAG,UAAU,EAAE,MAAM,CAAC,CAAC;IAClE,CAAC;IACH,yBAAC;AAAD,CAAC,AA5BD,CAAwC,SAAS,GA4BhD","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as aggregators from './aggregators';\nimport {\n  MetricRecord,\n  MetricKind,\n  Aggregator,\n  MetricDescriptor,\n} from './types';\n\n/**\n * Base class for all processor types.\n *\n * The processor is responsible for storing the aggregators and aggregated\n * values received from updates from metrics in the meter. The stored values\n * will be sent to an exporter for exporting.\n */\nexport abstract class Processor {\n  protected readonly _batchMap = new Map<string, MetricRecord>();\n\n  /** Returns an aggregator based off metric descriptor. */\n  abstract aggregatorFor(metricKind: MetricDescriptor): Aggregator;\n\n  /** Stores record information to be ready for exporting. */\n  abstract process(record: MetricRecord): void;\n\n  checkPointSet(): MetricRecord[] {\n    return Array.from(this._batchMap.values());\n  }\n}\n\n/**\n * Processor which retains all dimensions/attributes. It accepts all records and\n * passes them for exporting.\n */\nexport class UngroupedProcessor extends Processor {\n  aggregatorFor(metricDescriptor: MetricDescriptor): Aggregator {\n    switch (metricDescriptor.metricKind) {\n      case MetricKind.COUNTER:\n      case MetricKind.UP_DOWN_COUNTER:\n        return new aggregators.SumAggregator();\n\n      case MetricKind.OBSERVABLE_COUNTER:\n      case MetricKind.OBSERVABLE_UP_DOWN_COUNTER:\n      case MetricKind.OBSERVABLE_GAUGE:\n        return new aggregators.LastValueAggregator();\n\n      case MetricKind.HISTOGRAM:\n        return new aggregators.HistogramAggregator(\n          metricDescriptor.boundaries || [Infinity]\n        );\n\n      default:\n        return new aggregators.LastValueAggregator();\n    }\n  }\n\n  process(record: MetricRecord): void {\n    const attributes = Object.keys(record.attributes)\n      .map(k => `${k}=${record.attributes[k]}`)\n      .join(',');\n    this._batchMap.set(record.descriptor.name + attributes, record);\n  }\n}\n"]}
{"version":3,"file":"ObservableBaseMetric.js","sourceRoot":"","sources":["../../src/ObservableBaseMetric.ts"],"names":[],"mappings":";;;AAmBA,uDAAoD;AAGpD,qCAAkC;AAClC,yDAAsD;AAEtD,MAAM,aAAa,GAAG,GAAG,EAAE,GAAE,CAAC,CAAC;AAE/B;;;GAGG;AACH,MAAsB,oBACpB,SAAQ,eAAuB;IAI/B,YACE,IAAY,EACZ,OAA0B,EACT,UAAqB,EACtC,QAAkB,EAClB,UAAsB,EACtB,sBAA8C,EAC9C,QAA8D;QAE9D,KAAK,CAAC,IAAI,EAAE,OAAO,EAAE,UAAU,EAAE,QAAQ,EAAE,sBAAsB,CAAC,CAAC;QANlD,eAAU,GAAV,UAAU,CAAW;QAOtC,IAAI,CAAC,SAAS,GAAG,QAAQ,IAAI,aAAa,CAAC;IAC7C,CAAC;IAES,eAAe,CAAC,UAA0B;QAClD,OAAO,IAAI,iCAAe,CACxB,UAAU,EACV,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,UAAU,EACf,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,IAAI,CAAC,WAAW,CAAC,CAChD,CAAC;IACJ,CAAC;IAEQ,KAAK,CAAC,eAAe;QAC5B,MAAM,gBAAgB,GAAG,IAAI,mCAAgB,EAAE,CAAC;QAChD,MAAM,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,CAAC;QAEvC,IAAI,CAAC,eAAe,CAAC,gBAAgB,CAAC,CAAC;QAEvC,OAAO,KAAK,CAAC,eAAe,EAAE,CAAC;IACjC,CAAC;IAES,eAAe,CAAC,gBAAkC;QAC1D,gBAAgB,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,UAAU,EAAE,EAAE;YACpD,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YACzC,UAAU,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAC3B,CAAC,CAAC,CAAC;IACL,CAAC;IAED,WAAW,CAAC,KAAa;QACvB,OAAO;YACL,KAAK;YACL,UAAU,EAAE,IAA4B;SACzC,CAAC;IACJ,CAAC;CACF;AAjDD,oDAiDC","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as api from '@opentelemetry/api-metrics';\nimport { Observation } from '@opentelemetry/api-metrics';\nimport { InstrumentationLibrary } from '@opentelemetry/core';\nimport { Resource } from '@opentelemetry/resources';\nimport { BoundObservable } from './BoundInstrument';\nimport { Processor } from './export/Processor';\nimport { MetricKind, MetricRecord } from './export/types';\nimport { Metric } from './Metric';\nimport { ObservableResult } from './ObservableResult';\n\nconst NOOP_CALLBACK = () => {};\n\n/**\n * This is a SDK implementation of Base Observer Metric.\n * All observables should extend this class\n */\nexport abstract class ObservableBaseMetric\n  extends Metric<BoundObservable>\n  implements api.ObservableBase {\n  protected _callback: (observableResult: api.ObservableResult) => unknown;\n\n  constructor(\n    name: string,\n    options: api.MetricOptions,\n    private readonly _processor: Processor,\n    resource: Resource,\n    metricKind: MetricKind,\n    instrumentationLibrary: InstrumentationLibrary,\n    callback?: (observableResult: api.ObservableResult) => unknown\n  ) {\n    super(name, options, metricKind, resource, instrumentationLibrary);\n    this._callback = callback || NOOP_CALLBACK;\n  }\n\n  protected _makeInstrument(attributes: api.Attributes): BoundObservable {\n    return new BoundObservable(\n      attributes,\n      this._disabled,\n      this._valueType,\n      this._processor.aggregatorFor(this._descriptor)\n    );\n  }\n\n  override async getMetricRecord(): Promise<MetricRecord[]> {\n    const observableResult = new ObservableResult();\n    await this._callback(observableResult);\n\n    this._processResults(observableResult);\n\n    return super.getMetricRecord();\n  }\n\n  protected _processResults(observableResult: ObservableResult): void {\n    observableResult.values.forEach((value, attributes) => {\n      const instrument = this.bind(attributes);\n      instrument.update(value);\n    });\n  }\n\n  observation(value: number): Observation {\n    return {\n      value,\n      observable: this as ObservableBaseMetric,\n    };\n  }\n}\n"]}